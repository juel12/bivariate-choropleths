<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Julia E. Koller">

<title>Bivariate Choreopleths Documentation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="Bivariate Choreopleths Documentation_files/libs/clipboard/clipboard.min.js"></script>
<script src="Bivariate Choreopleths Documentation_files/libs/quarto-html/quarto.js"></script>
<script src="Bivariate Choreopleths Documentation_files/libs/quarto-html/popper.min.js"></script>
<script src="Bivariate Choreopleths Documentation_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Bivariate Choreopleths Documentation_files/libs/quarto-html/anchor.min.js"></script>
<link href="Bivariate Choreopleths Documentation_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Bivariate Choreopleths Documentation_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Bivariate Choreopleths Documentation_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Bivariate Choreopleths Documentation_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Bivariate Choreopleths Documentation_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Bivariate Choreopleths Documentation</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Julia E. Koller </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="a-shiny-app-for-bivariate-choropleths" class="level1">
<h1>A Shiny app for bivariate Choropleths</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This app was created using shiny <span class="citation" data-cites="Chang.2018">(<a href="#ref-Chang.2018" role="doc-biblioref">Chang et al. 2018</a>)</span> with R version 3.5.2 (2018-12-20) and later updated with R version 4.1.3 (2022-03-10). Its purpose is to create bivariate choropleths.</p>
<p>Creating bivariate choreopleths can be a bit tricky and somewhat time-consuming, especially for newbies in R and similar programs. Therefore, an app might be a convenient way to simplify the creation of bivariate choreopleths.</p>
<p>The app was not specifically created for psychological purposes. However, data visualization and exploration are gaining importance for psychological research. The current app can be a helpful tool for exploring potential relationships between two variables across different geographical areas or may be used to visualize the findings of such. The app can be applied to any topic, including psychological questions, depending on the data. For example, a health psychologist may be interested in one of the many Eurostat datasets concerned with health (e.g.&nbsp;self-perceived health).</p>
<p>At this point, it has to be noted, that data exploration tools should never be used for fishing, which can severely bias results. Furthermore, data visualization can not replace statistical testing of previously defined hypotheses.</p>
</section>
<section id="bivariate-choropleths" class="level2">
<h2 class="anchored" data-anchor-id="bivariate-choropleths">Bivariate Choropleths</h2>
<p>The bivariate choropleths created in the app are being created following the instructions by <span class="citation" data-cites="ArtSteinmetz.2017">Art Steinmetz (<a href="#ref-ArtSteinmetz.2017" role="doc-biblioref">2017</a>)</span>.</p>
<p>The variables compared in the plot are being normalized on the population sizes. This is important because otherwise, population size differences of the geographic areas would be reflected in the choropleth <span class="citation" data-cites="JoshuaStevens.2015">(<a href="#ref-JoshuaStevens.2015" role="doc-biblioref">Joshua Stevens 2015</a>)</span>. Both variables are categorized into three groups. Subsequently, a single variable combining the classified variables is created. This variable contains nine (3*3) groups, each corresponding to a single color. The geographical shapes, corresponding to the geographic areas in the dataset, are then colored based on this variable. All bivariate choropleths are produced using the package tmap <span class="citation" data-cites="Tennekes.2018">(<a href="#ref-Tennekes.2018" role="doc-biblioref">Tennekes 2018</a>)</span> and plotted on a world map using leaflet <span class="citation" data-cites="Cheng.2018">(<a href="#ref-Cheng.2018" role="doc-biblioref">Cheng, Karambelkar, and Xie 2018</a>)</span>.</p>
</section>
<section id="own-dataset" class="level2">
<h2 class="anchored" data-anchor-id="own-dataset">Own dataset</h2>
<p>The user can choose to upload an own dataset. However, so far only excel datasets (.xls or .xlsx) can be uploaded. Moreover, the data need to be cleaned beforehand. The dataset should be provided in wide format.</p>
<p>After uploading a dataset, a table is rendered displaying the data to help the user select variables. The user needs to select two variables of interest and a variable with the geographic areas (either German federal states or European countries) in the sidebar. Optionally, a variable containing some kind of time information (e.g.&nbsp;years) can be specified, in which case any level of the variable can be selected. Furthermore, the user needs to select the map that will be used to plot the data. So far, only maps of European countries and German federal states are available. Maps can not be uploaded by the user. The levels of the dataset variable containing the geographic area needs to correspond to the map.</p>
<p>If a time variable and any level of the variable are selected, the dataset will be filtered based on the level of this variable (e.g.&nbsp;only data from the year 2015 will be used going forward). The variables that are compared in the bivariate choropleth will be normalized on the variable containing the population sizes for each area.</p>
<p>After the “Create plot” button has been clicked, the bivariate choreopleth and a legend will be rendered. A mapshot of the bivariate choreopleth can be downloaded using “webshot” <span class="citation" data-cites="webshot">(<a href="#ref-webshot" role="doc-biblioref">Chang 2023</a>)</span>. However, as this requires “PhantomJS”, you might need to install it first using the following code:</p>
<div class="sourceCode" id="cb1" data-eval="false"><pre class="sourceCode R code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>webshot<span class="sc">::</span><span class="fu">install_phantomjs</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="eurostat-data" class="level2">
<h2 class="anchored" data-anchor-id="eurostat-data">Eurostat data</h2>
<p>Instead of uploading an own dataset, the user can choose to use any Eurostat dataset. The app allows to search for Eurostat datasets by entering a search term into a search bar. Once the user has found a dataset of interest, he or she can enter the code of the dataset into a second text box. The dataset will then be automatically downloaded. Access to Eurostat data is obtained via the package “eurostat” <span class="citation" data-cites="Lahti.2017">(<a href="#ref-Lahti.2017" role="doc-biblioref">Lahti et al. 2017</a>)</span>.</p>
<p>After a dataset has been downloaded, a table displaying the data will be rendered. First of all, the user has to select the variables which are of interest (either two different variables or the same variable twice).</p>
<p>In the next step, a table with column filters is rendered. The user needs to filter all variables which are not blocked. The user should select only one level per column and a year between 1990 and 2016. If these conditions are not met, the filters can not be applied. The columns containing the previously selected variables as well as the variables with the geographic areas and values are blocked and can not be filtered.</p>
<p>Based on the applied filters, the Eurostat data are then subsetted and reshaped from long to wide format.</p>
<p>Subsequently, the levels of the previously selected variables of interest are shown and need to be selected.</p>
<p>After the “Create plot” button has been clicked, a variable with the population density will be added to the data on which the selected levels will be normalized. Currently, the population density is retrieved from the Eurostat dataset “demo_r_d3dens”. However, population densities of different European countries are only available for years between 1990 and 2016, which is a limitation. Also, it has to be noted, that all rows from the dataset for which the geographical area does correspond to any area given in the “demo_r_d3dens” dataset will be removed.</p>
<p>Finally, the bivariate choropleth and a legend will be rendered. A mapshot of the bivariate choropleth may be downloaded. Furthermore, the final dataset can also be downloaded and may be uploaded to the app later on to reproduce the same plot.</p>
</section>
<section id="credit" class="level2">
<h2 class="anchored" data-anchor-id="credit">Credit</h2>
<p>The app was created during a seminar at the University of Konstanz (course instructor: Matthias Bannert) in 2018/19 by Jenny Kloster and Julia E. Koller. Both contributed to the app concept. Jenny Kloster focused on the data management required for the use of Eurostat datasets and the “eurostat” package. Julia E. Koller programmed the app with “shiny” using instructions from <span class="citation" data-cites="ArtSteinmetz.2017">Art Steinmetz (<a href="#ref-ArtSteinmetz.2017" role="doc-biblioref">2017</a>)</span> and <span class="citation" data-cites="JoshuaStevens.2015">Joshua Stevens (<a href="#ref-JoshuaStevens.2015" role="doc-biblioref">2015</a>)</span>. Furthermore, she updated the app and documentation in 2023.</p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-ArtSteinmetz.2017" class="csl-entry" role="listitem">
Art Steinmetz. 2017. <span>“<span class="nocase">Exploring the distribution of NYC Pre-K seats vs. neighborhood income</span>.”</span> <a href="https://rpubs.com/apsteinmetz/prek">https://rpubs.com/apsteinmetz/prek</a>.
</div>
<div id="ref-webshot" class="csl-entry" role="listitem">
Chang, Winston. 2023. <span>“Webshot: Take Screenshots of Web Pages.”</span> <a href="https://CRAN.R-project.org/package=webshot">https://CRAN.R-project.org/package=webshot</a>.
</div>
<div id="ref-Chang.2018" class="csl-entry" role="listitem">
Chang, Winston, Joe Cheng, J. J. Allaire, Yihui Xie, and Jonathan McPherson. 2018. <span>“<span class="nocase">shiny: Web Application Framework for R</span>.”</span> <a href="https://CRAN.R-project.org/package=shiny">https://CRAN.R-project.org/package=shiny</a>.
</div>
<div id="ref-Cheng.2018" class="csl-entry" role="listitem">
Cheng, Joe, Bhaskar Karambelkar, and Yihui Xie. 2018. <span>“<span class="nocase">leaflet: Create Interactive Web Maps with the JavaScript ’Leaflet’ Library</span>.”</span> <a href="https://CRAN.R-project.org/package=leaflet">https://CRAN.R-project.org/package=leaflet</a>.
</div>
<div id="ref-JoshuaStevens.2015" class="csl-entry" role="listitem">
Joshua Stevens. 2015. <span>“<span class="nocase">Bivariate Choropleth Maps: A How-to Guide</span>.”</span> <a href="http://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/">http://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/</a>.
</div>
<div id="ref-Lahti.2017" class="csl-entry" role="listitem">
Lahti, Leo, Janne Huovari, Markus Kainu, and Przemyslaw Biecek. 2017. <span>“<span class="nocase">eurostat R package</span>”</span> 9 (1): 385–92. <a href="https://journal.r-project.org/archive/2017/RJ-2017-019/index.html">https://journal.r-project.org/archive/2017/RJ-2017-019/index.html</a>.
</div>
<div id="ref-Tennekes.2018" class="csl-entry" role="listitem">
Tennekes, Martijn. 2018. <span>“<span class="nocase">tmap: Thematic Maps in R</span>.”</span> <em><span>Journal of Statistical Software</span></em> 84 (6): 1–39. <a href="https://doi.org/10.18637/jss.v084.i06">https://doi.org/10.18637/jss.v084.i06</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>